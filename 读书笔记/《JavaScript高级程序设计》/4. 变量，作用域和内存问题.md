# 变量，作用域和内存问题

[TOC]

## 基本类型和引用类型的值

ECMAScript的基本数据类型有undefined, null, number, string, boolean 这五种基本数据类型，ES2015/ES6还有Symbol的基本数据类型。

基本数据的赋值就是重新创建一个值，在给新的数据类型。

引用数据的赋值就是传递的一个引用地址。

函数参数的传递都是按值传递的。也就是，基本类型值就是复制，引用类型值就是传递引用地址。



## 执行环境及作用域

每一个函数都有自己的执行环境。当执行流进入到一个函数中时，函数的环境就会被推入到一个**环境栈**中。函数执行完毕后，栈将其环境弹出，把控制权交还给之前的执行环境。

当代码在一个环境中执行时，会创建变量的一个**作用域链**，作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终是当前执行的代码所在环境的**变量对象**。如果这个环境是一个函数，则将其**活动对象**作为变量对象。活动对象在最开始之前只有一个变量`arguments`对象。作用域链中下一个变量对象来自外部的环境，再下一个变量对象来自下下一个包含环境。

在作用域解析中，所有的变量声明都会提升到作用域最前面。例如：

```javascript
var a = '1';
function context(){
  console.log(a); // undefined
  var a = '2';
  console.log(a); // '2'
}
context();

// 实际形式
var a = '1';
function context(){
  var a;
  console.log(a);
  a = '2';
  console.log(a);
}
context();
```

在作用域解析中，所有的函数也会被提升，多个重复的函数，后边的会覆盖前面的。多个重复变量声明不会有问题，因为最开始这个变量就是`undefined`。

### 延长作用域链

在两种情况下会发生作用域链延长的现象：

- `try...catch...`的`catch`块
- `with`语句

对于`with`语句，作用域链的前端添加的是`with`语句指定的变量对象。对于`try...catch...`的`catch`块，添加的是一个全新的对象，该对象有被抛出的错误对象的声明。



## 垃圾回收

### 标记清除

JS中最常用的垃圾回收方式就是**标记清除**(mark-and-sweep)。

当变量进入环境时，就将变量标记为‘进入环境’，从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为‘离开环境’。

### 引用计数

另一个不太常见的垃圾回收策略叫做**引用计数**(reference counting)。

引用计数的含义是跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型赋值给该变量时，则这个值引用次数就是1。如果又被赋给另一个变量，则该值得引用次数加1。当这个值得引用次数为0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

但是，引用计数出现了一个严重的问题：**循环引用**。如下：

```javascript
function problem(){
  var objA = {};
  var objB = {};
  objA.next = objB;
  objB.next = objA;
}
```

在函数`problem`执行中，`objA`和`objB`的引用计数都是2。如果采用标记清楚的方式没有问题，但是采用引用计数，由于他们引用不会为0。如果这个函数被多次的调用，就会导致大量内存得不到回收。由于这个原因，Navigator3使用的引用计数策略在Navigator4中取消了。

但是引用计数导致的麻烦并没有就此终结。

我们知道，IE中一部分对象并不是原生JS对象。例如BOM, DOM中对象就是使用C++以COM(Component Object Model， 组件对象模型)对象的形式实现的，而COM垃圾回收机制就是引用计数。例如：

```javascript
var element = document.getElementById('some_element');
var obj = {};
obj.element = element;
element.obj = obj;
```

### 性能问题

垃圾回收器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。

### 管理内存

- 为不用的变量手动进行释放，将其设置为`null`