#深入浅 出之模块机制

[TOC]

##Node的模块实现

Node在实现中并非完全按照CommonJS规范实现，而是对模块规范进行了一定的取舍，同时也增加了少许自身需要的特性。

在Node中引入模块，需要经历3个过程：

1. 路径分析
2. 文件定位
3. 编译执行

在Node中，模块分为两类：一类是Node提供的模块，称之为**系统模块**；另一类是用户编写的模块，称之为**文件模块**。

- 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位与编译执行这两部可以省略掉，并且在路径分析中优化判断，所以它的加载速度是最快的。
- 文件模块则在运行时动态加载，需要完整的路径分析，文件定位，编译执行过程，速度比核心模块慢。



###优化从缓存加载

Node对引入过的模块都会进行缓存，以减少而二次引入时的开销。不同于浏览器的缓存。浏览器仅仅缓存文件，而Node缓存的是编译执行之后的对象。

不论是核心模块还是文件模块，`require()`方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级。不同之处在于核心模块的缓存检查优先于文件模块的缓存检查。



###路径分析与文件定位

####模块标识符分析

- 核心模块

核心模块的优先级仅次于缓存加载，它在Node的原代码编译过程中已经编译为二进制代码，其加载过程最快。

如果试图加载与一个核心模块标识符相同的自定义模块，将是无法加载的。必须选择不同的标识符或者换用路径的方式。

- 路径形式的文件模块

以`.`, `..`和`/`开头的标识符，这里都被当做文件模块来处理。在分析路径模块时，`require()`会将其转为真实路径，并以真正路径作为索引，将编译后的结果放到缓存中，以便二次加载。其加载速度慢于核心模块。

- 自定义模块

自定义模块指非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块查找最费时。所以最慢。

在介绍自定义模块查找方式前，需要介绍**模块路径**的概念。

模块路径是Node在定位文件模块的具体文件时定制的查找策略，具体表现为一个路径组成的数组。

例如：

```javascript
// app.js
console.log(module.paths);
// ["/home/nodejs/project/node_modules", "/home/nodejs/node_modules", "/home/node_modules", "/node_modules"]
```

####文件定位

从缓存中加载的优化策略使得二次引入不需要进行路径分析，文件定位和编译执行，大大提高了再次加载模块的效率。

但在文件的定位过程中，还需要注意一些细节。

- 文件扩展名分析

因为Node是单线程的，所以这里是一个会引发性能问题的地方。小诀窍是：如果是.node和.json文件，在传递时，自己不足扩展名。另一个诀窍就是：同步和缓存配合，可以大幅度缓解Node单线程中阻塞式调用的缺陷。

- 目录分析和包

在分析标识符的过程中，`require()`通过分析文件扩展名之后，可能没有查到对应文件，但是查找到了一个目录，在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包处理。

如果在路径分析的过程中没有成功定位任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都遍历完毕，依然没找到，这回抛出查找失败异常。 



因为Node是单线程的，所以这里是一个会引发性能问题的地方。小诀窍是：如果是.node和.json文件，在传递时，自己不足扩展名。另一个诀窍就是：同步和缓存配合



**总结来说就是:**

当 Node 遇到 require(X) 时，按下面的顺序处理。

（1）如果 X 是内置模块（比如 require('http'）) 

（1）如果 X 是内置模块（比如 require('http'）) 
　　a. 返回该模块。 

（1）如果 X 是内置模块（比如 require('http'）) 
　　a. 返回该模块。 
　　b. 不再继续执行。

（2）如果 X 以 "./" 或者 "/" 或者 "../" 开头 

（2）如果 X 以 "./" 或者 "/" 或者 "../" 开头 
　　a. 根据 X 所在的父模块，确定 X 的绝对路径。 

（2）如果 X 以 "./" 或者 "/" 或者 "../" 开头 
　　a. 根据 X 所在的父模块，确定 X 的绝对路径。 
　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。

> - X
> - X.js
> - X.json
> - X.node

　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。

> - X/package.json（main字段）
> - X/index.js
> - X/index.json
> - X/index.node

（3）如果 X 不带路径 

（3）如果 X 不带路径 
　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。 

（3）如果 X 不带路径 
　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。 
　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。

（4） 抛出 "not found"

