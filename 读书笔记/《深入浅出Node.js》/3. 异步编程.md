#异步编程

[TOC]

##函数式编程

###高阶函数

高阶函数就是把函数作为参数，或是将函数作为返回值的函数。

```javascript
function foo(x){
  return function(){
  	return x;
  }
}
```

高阶函数在JS中比比皆是，其中ES5中提供的一些数组方法（forEach, map, reduce, reduceRight, filter, every, some）。



###偏函数用法

偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。这句话拗口，我们看下面的例子：

```javascript
var toString = Object.prototype.toString;
var isString = function(obj){
  return toString.call(obj) === "[object String]";
};
var isFunction = function(obj){
  return toString.call(obj) === "[Object Function]";
};
```

在JS中进行类型判断，入过我们都按上面的格式进行书写，将会有很多的代码冗余。为了解决复用问题，我们引入一个新函数，这个新函数可以如工厂一样创建一些类似的函数。

```javascript
var isType = function(type){
  return function(obj){
  	return toString.call(obj) == "[object "+type+"]";	
  }
};
var isString = isType("String");
var isFunction = isFunction("Function");
```

上面这种通过指定部分参数来产生一个新的定制函数的形式就是**偏函数**

偏函数应用在异步编程中十分的常见。著名的underscore库的`after`函数就是偏函数。

```javascript
_.after = function(times, func){
  if (times <= 0) return func();
  return function(){
  	if (--times < 1) { return func.apply(this, arguments); }
  }
}
```



##异步编程的优势与难点

###优势

Node带来的最大特性莫过于基于事件驱动的非阻塞I/O模型，这是它的灵魂所在。非阻塞I/O可以使得CPU与I/O并不相互依赖等待，让资源得到更好的利用。对于网络应用而言，并行带来的想象空间更大，延展开来的是分布式和云。并行使得各个单点之间能够更有效的组织起来。

![async_programming_io](images/async_programming_io.PNG)

如果采用传统的同步I/O模型，分布式计算性能的折扣将会是明显的

![async_programming_io2](images/async_programming_io2.PNG)

利用事件循环的方式，JS线程像个分配任务和处理结果的大管家，I/O线程池里的线程都是小二，负责兢兢业业地完成任务，小二与管家之间互不依赖，所以可以保持整体的高效率。

这个模型缺点则在于管家无法承担过多的细节性任务，如果承担过多，则会影响到任务的调度，管家很忙，小二却很闲，结局则是整体效率的降低。

Node为了解决编程模型中阻塞I/O的性能问题，采用了单线程模型，这导致Node更像一个处理I/O密集问题的能手，而CPU密集型则取决于管家的能耐如何。

由于时间循环模型需要应对海量请求，海量请求同时作用在单线程上，就需要防止任何一个计算耗费过多的CPU时间片。至于是计算密集型还是I/O密集型，只要计算不影响异步I/O的调度，那就不构成问题。建议对CPU的消耗不要超过10ms，或者将大量的计算分解为诸多的小量计算，通过setImmediate进行调度。只要合理利用Node的异步模型和V8高性能，就可以充分的发挥CPU和I/O资源的优势。



###难点

#### 难点1：异常处理

过去处理异常

```java
try {
  // TODO
} catch (e) {
  // TODO
}
```

Node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，这表明异步调用没有异常抛出。

```javascript
async(function(err, callback){
  if(err){
  	// 有异常
  }
})
```

在异步编程中，另一个容易犯的错误是对用户传递的回调函数进行异常捕获，如下:

```javascript
try{
  req.body = JSON.parse(buf, optiosn.reviver);
  callback()；
}catch(err){
  err.body = buf;
  err.status = 400;
  callback(err);
}
```

上述代码，如果callback()出错，错误将被`try...catch...`代码块捕获，callback会被执行两次，这明显不符合业务逻辑。正确逻辑如下：

```javascript
try{
  req.body = JSON.parse(buf, optiosn.reviver);
}catch(err){
  err.body = buf;
  err.status = 400;
  callback(err);
}
callback();
```



#### 难点2：函数嵌套过深

例如遍历目录：

```javascript
fs.readdir(path.join(__dirname, ".."), function(err, files){
  files.forEach(function(filename, index){
  	fs.readFile(filename, "utf8", function(err, file){
      // TODO
	});
  });
});
```

对于上述场景，由于两次操作存在依赖，嵌套情有可原。那么，在网页渲染过程中，数据，模板，资源文件，三者之间并不存在依赖，但最终渲染结果中三者缺一不可。

```javascript
fs.readFile(template_path, "utf8", function(err, template){
  db.query(sql, function(err, data){
  	req.get(function(err, resources){
      // TODO
	});
  });
});
```



#### 难点3：阻塞代码

对于进入JS世界不久的开发者，比较纳闷的是为何没有`sleep`这种线程沉睡功能。唯独有的是`setTimeout()`，和`setInterval()`这两个函数，但是让人惊讶的是，他们并不会阻塞后续代码的执行。所以，多半程序员会用下面代码模拟sleep。

```javascript
var start = new Date();
while(new Date() - start < 1000){

}
```

但是事实是糟糕的，这段代码会继续占用CPU进行判断，与真正的线程沉睡相去甚远，完全破坏了事件循环的调度。由于Node单线程的原因，CPU资源全都会用于服务这段代码，导致其余任何请求都会得不到响应。



### 难点4：多线程编程

浏览器提出**Web Workers**，它通过将JS执行与UI渲染分离，可以很好的利用多核CPU为大量计算服务。同时前端Web Workers也是一个利用消息机制合理使用多核CPU的理想模型。下图为web workers工作示意图

![async_programming_web_workers](images/async_programming_web_workers.PNG)

遗憾在于前端浏览器存在对标准的滞后性，Web Workers并没有广泛的应用起来。另外Web Workers能够解决利用CPU和减小阻塞UI渲染，但是不能解决UI渲染效率问题。Node借鉴了这个模式，child_process是其基础API，cluster模块是更深层次的应用。



#### 难点5：异步转同步



## 异步编程解决方案

目前，异步编程解决方案有如下3中：

- 事件发布/订阅模式
- Promise/Deferred模式
- 流程控制库



###事件发布/订阅模式

事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称为发布/订阅模式

Node自身提供了events模块，是发布/订阅模式的一个简单实现，Node中部分模块都继承自它，这个模块比前段浏览器中的大量DOM事件简单，不存在事件冒泡，也不存在`preventDefault()`, `stopPropagation()`, `stopImmediatePropagation()`等控制事件传递的方法。它具有`addListener()`, `on()`, `once()`, `removeListener()`, `removeAllListener()`和`emit()`等基本的事件监听的方法实现。

事件发布/订阅模式自身并无同步和异步调用的问题，但在Node中，emit()调用多半是伴随事件循环而异步触发的，所以我们说事件发布/订阅广泛应用于异步编程。