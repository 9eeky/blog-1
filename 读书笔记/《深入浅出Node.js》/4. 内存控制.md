#内存控制

[TOC]

说道内存泄漏，大家首先会想起的也只是早起版本的IE中JavaScript与DOM交互时发生的问题。如果页面的内存占用过多，基本等不到进行垃圾回收，用于已经不耐烦地刷新了当前页面。

基于无阻塞，事件驱动建立的Node服务，具有内存消耗低的有点，非常适合处理海量的网络请求。在海量请求的前提下，开发者就需要考虑一写平常不会形成影响的问题。**内存控制**正式在海量请求和长时间运行的前提下进行探讨的。

##V8的垃圾回收机制与内存限制

我们在学习JS编程中，听说过它和Java一样，由垃圾回收机制来进行自动的内存管理，这使得开发者不想C/C++程序员那样在编写代码的过程中时刻关注内存的分配和释放问题。但在浏览器中进行开发时，几乎很少有人能遇到垃圾回收对应用程序构成性能影响的情况。Node极大扩宽了JS的应用场景，当主流应用场景从客户端延伸到服务器之后，我们就能发现，对于性能敏感的服务器端程序，内存管理的好坏，垃圾回收情况是否优良，都会对服务构成影响。而在Node中，这一切都与Node的JS引擎V8息息相关。

### Node与V8

09年，Node创始人Ryan Dahl选择V8来作为Node的JS脚本引擎，这离不开第三次浏览器大战。那次大战中，Google的Chrome浏览器以期优异的性能成为焦点。V8出现至今，JS一改它作为脚本语言性能低下的形象。V8的性能优势使得JS写高性能后台服务程序成为可能。接下来Ryan Dahl选择了JS，选择了V8，在事件驱动，非阻塞I/O模型的设计下实现了Node。

V8作为虚拟机，性能表现优异，这与它的领导者有莫大的渊源，Chrome的成功离不开它背后的天才------Lars Bak。在开发V8前，其在Sun公司开发高性能的Java虚拟机。

Node在JS的执行上直接受益于V8，可以随着V8的升级享受到更好的性能或新的语言特性（如ES5和ES6）等，同时也受到V8的一些限制，尤其是本章要重点讨论的内存限制

### V8的内存限制

在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而Node中通过JS使用内存时就会发现只能使用部分内存（64位系统下约1.4G，32位系统下约0.7G）。在这样的限制下，会导致Node无法直接操作大内存对象。这样在单个Node进程的情况下，计算机内存的资源无法得到充足的使用。

造成这个原因主要是Node基于V8构建，所以在Node中使用的JS对象基本上都是通过V8自己的方式进行分配和管理的。V8这套内存管理机制在浏览器端绰绰有余，但是对Node，这却限制了开发者随心所欲使用大内存你的想法。

### V8的对象分配

在V8中，所有JS对象都是通过堆来进行分配的。Node提供了V8内存使用情况查询的方式：

```shell
$ node
> process.memoryUsage() # 查询内存使用情况
```

在上述代码中，`memoryUsage()`方法返回3个属性，`heapTotal`和`heapUsed`是V8的堆内存使用情况，前者是已申请到的堆内存，后者是当前使用的量。`rss`后续介绍：

![5-heap](images/5-heap.PNG)

当我们在代码中声明变量并赋值时，所使用对象的内存就是分配在堆中。如果申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆内存的大小超过V8的限制为止。

至于V8为何限制堆大小，表层原因是因为V8设计之初是为浏览器服务的，浏览器用不到那么多内存。深层原因是V8的垃圾回收机制的限制。按照官方的说法，以1.5G的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至需要1秒以上。这是垃圾回收中引起JS线程暂停执行的时间，在这样的时间花销下，应用的性能和相应能力都会直线下降。

当然，这个限制也不是不能打开，V8依然提供了选项让我们使用更多的内存。Node启动时可以传递`--max-old-space-size`和`--max-new-space-size`来调整内存限制的大小。

```shell
> node --max-old-space-size=1700 test.js # MB
> node --max-new-space-size=1024 test.js # KB
```

### V8的垃圾回收机制

