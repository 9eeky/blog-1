#Unicode与JavaScript详解

[TOC]

##引言

在作为一名程序猿的道路中，编写代码中经常会让我们去选择编码方式，打开别人的代码经常会乱码，这些都和语言的编码方式有关。

下面，我将对Unicode字符串进行一个较为详尽的讲解，这些内容都是从网上整合而来。

##ASCII

我们都知道，计算机的内部，所有信息最终都是存储为二进制的字符串。每一个二进制都有0或1两种状态，因此八个二进制位有256种状态(2^8)，这被称为一个**字节(Byte)**。这256种状态从00000000到11111111。

上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了同一的规定，被称为**ASCII**，一直沿用至今。

ASCII码一共规定128个字符的编码，比如空格"SPACE"是32(0010 0000)等。只占用了8位中的低7位，最高1位为0.



##非ASCII编码

英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。

但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。

至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。



##Unicode

Unicode源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。

**它从0开始，为每个符号指定一个编号，这叫做"码点"（code point）。**比如，码点0的符号就是null（表示所有二进制位都是0）。

```
U+0000 = null
```

上式中，U+表示紧跟在后面的十六进制数是Unicode的码点。

*小结：*

*1. 从0开始编号u+0000 = null*

*2. 最新版为7.0版; 3. 攻击109449个字符，包含CJK字符74500个*



目前，Unicode的最新版本是7.0版，一共收入了109449个符号，其中的中日韩文字为74500个。可以近似认为，全世界现有的符号当中，三分之二以上来自东亚文字。比如，中文"好"的码点是十六进制的597D。

这么多符号，Unicode不是一次性定义的，而是**分区定义**。每个区可以存放65536个（216）字符，称为一个**平面**（plane）。目前，一共有17个（25）平面，也就是说，整个Unicode字符集的大小现在是221。

最前面的65536个字符位，称为**基本平面**（缩写BMP），它的码点范围是从0一直到216-1，写成16进制就是从U+0000到U+FFFF。所有最常见的字符都放在这个平面，这是Unicode最先定义和公布的一个平面。

剩下的字符都放在**辅助平面**（缩写SMP），码点范围从U+010000一直到U+10FFFF。

*小结：*

*1. 2^16个号码组成一个平面*

*2. 目前共有17个平面，整体空间大小为:2^21*

*3. 1个基本平面(BMP): U+0000 --- U+FFFF*

*4. 16个辅助平面(SMP): U+10000 --- U+10FFFF*



##UTF-32

Unicode只规定了每个字符的码点，到底用什么样的字节序表示这个码点，就涉及到编码方法。

**最直观的编码方法是，每个码点使用四个字节表示，字节内容一一对应码点。这种编码方法就叫做UTF-32。**比如，码点0就用四个字节的0表示，码点597D就在前面加两个字节的0。

```
U+0000 = 0x0000 0000

U+597D = 0x0000 597D
```

*小结:*

*1. 4个字节表示一个字符，完全对饮Unicode编码。*

*2. 查询效率高，时间复杂度为O(1),但是这种方式浪费空间*

UTF-32的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比ASCII编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5标准就明文规定，网页不得编码成UTF-32。



##UTF-8

人们真正需要的是一种节省空间的编码方法，这导致了UTF-8的诞生。**UTF-8是一种变长的编码方法，字符长度从1个字节到4个字节不等。**越是常用的字符，字节越短，最前面的128个字符，只使用1个字节表示，与ASCII码完全相同。

| 编码范围                | 二进制表示                               | 字节   |
| ------------------- | ----------------------------------- | ---- |
| 0x0000 - 0x007F     | 0xxxxxxx                            | 1    |
| 0x0080 - 0x07FF     | 110xxxxx 10xxxxxx                   | 2    |
| 0x0800 - 0xFFFF     | 1110xxxx 10xxxxxx 10xxxxxx          | 3    |
| 0x010000 - 0x10FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx | 4    |

下面，还是以汉字"严"为例，演示如何实现UTF-8编码。

已知"严"的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此"严"的UTF-8编码需要三个字节，即格式是"1110xxxx 10xxxxxx 10xxxxxx"。然后，从"严"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，"严"的UTF-8编码是"11100100 10111000 10100101"，转换成十六进制就是E4B8A5。

由于UTF-8这种节省空间的特性，导致它成为互联网上最常见的网页编码。



##UTF-16

UTF-16编码介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。

它的编码规则很简单：基本平面的字符占用2个字节，辅助平面的字符占用4个字节。**也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。**

于是就有一个问题，当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？

说来很巧妙，我也不知道是不是故意的设计，**在基本平面内，从U+D800到U+DFFF是一个空段**，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。

具体来说，辅助平面的字符位共有220个，也就是说，对应这些字符至少需要20个二进制位。UTF-16将这20位拆成两半，前10位映射在U+D800到U+DBFF（空间大小210），称为高位（H），后10位映射在U+DC00到U+DFFF（空间大小210），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。

**所以，当我们遇到两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。**



##UTF-16的转码公式

Unicode码点转成UTF-16的时候，首先区分这是基本平面字符，还是辅助平面字符。如果是前者，直接将码点转为对应的十六进制形式，长度为两字节。

```
U+597D = 0x597D
```

如果是辅助平面字符，Unicode 3.0版给出了转码公式。

```
H = Math.floor((c-0x10000) / 0x400)+0xD800 // 高位

L = (c - 0x10000) % 0x400 + 0xDC00 // 低位
```

以字符![](http://image.beekka.com/blog/2014/bg2014121121-1.png)为例，它是一个辅助平面字符，码点为U+1D306，将其转为UTF-16的计算过程如下。

```
H = Math.floor((0x1D306-0x10000)/0x400)+0xD800 = 0xD834

L = (0x1D306-0x10000) % 0x400+0xDC00 = 0xDF06
```

所以，字符![](http://image.beekka.com/blog/2014/bg2014121121-1.png)的UTF-16编码就是0xD834 DF06，长度为四个字节。



##JavaScript用的是哪种编码方式呢？

JavaScript语言采用Unicode字符集，但是只支持一种编码方法。

这种编码既不是UTF-16，也不是UTF-8，更不是UTF-32。上面那些编码方法，JavaScript都不用。

**JavaScript用的是UCS-2！**

**UCS-2！**，**UCS-2！**，**UCS-2！重要事说三遍！**



##UCS-2编码

怎么突然杀出一个UCS-2？这就需要讲一点历史。

互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是1988年成立的Unicode团队，另一个是1989年成立的UCS团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集。

1991年10月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是Unicode，并且修订此前发布的字符集，UCS的码点将与Unicode完全一致。

UCS的开发进度快于Unicode，1990年就公布了第一套编码方法UCS-2，使用2个字节表示已经有码点的字符。（那个时候只有一个平面，就是基本平面，所以2个字节就够用了。）UTF-16编码迟至1996年7月才公布，明确宣布是UCS-2的超集，即基本平面字符沿用UCS-2编码，辅助平面字符定义了4个字节的表示方法。

**两者的关系简单说，就是UTF-16取代了UCS-2，或者说UCS-2整合进了UTF-16。**所以，现在只有UTF-16，没有UCS-2。



##JavaScript的诞生背景

那么，为什么JavaScript不选择更高级的UTF-16，而用了已经被淘汰的UCS-2呢？

答案很简单：非不想也，是不能也。**因为在JavaScript语言出现的时候，还没有UTF-16编码。**

1995年5月，Brendan Eich用了10天设计了JavaScript语言；10月，第一个解释引擎问世；次年11月，Netscape正式向ECMA提交语言标准。对比UTF-16的发布时间（1996年7月），就会明白Netscape公司那时没有其他选择，只有UCS-2一种编码方法可用！



##JavaScript字符函数的局限

**由于JavaScript只能处理UCS-2编码，造成所有字符在这门语言中都是2个字节，如果是4个字节的字符，会当作两个双字节的字符处理。**JavaScript的字符函数都受到这一点的影响，无法返回正确结果。

还是以字符![](http://image.beekka.com/blog/2014/bg2014121121-1.png)为例，它的UTF-16编码是4个字节的0xD834 DF06。问题就来了，4个字节的编码不属于UCS-2，JavaScript不认识，只会把它看作单独的两个字符U+D834和U+DF06。前面说过，这两个码点是空的，所以JavaScript会认为![](http://image.beekka.com/blog/2014/bg2014121121-1.png)是两个空字符组成的字符串！

解决这个问题，必须对码点做一个判断，然后手动调整。下面是正确的遍历字符串的写法。

```javascript
while (++index < length) {
  // ...
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    output.push(character + string.charAt(++index));
  } else {
    output.push(character);
  }
}

// 上面代码表示，遍历字符串的时候，必须对码点做一个判断，只要落在0xD800到0xDBFF的区间，就要连同后面2个字节一起读取。
```

类似的问题存在于所有的JavaScript字符操作函数。

```javascript
- String.prototype.replace()
- String.prototype.substring()
- String.prototype.slice()

// 上面的函数都只对2字节的码点有效。要正确处理4字节的码点，就必须逐一部署自己的版本，判断一下当前字符的码点范围。
```

